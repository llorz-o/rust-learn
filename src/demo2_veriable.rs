fn main() {
    // 声明
    let a;
    // let 声明的不可变变量仅可初始化一次;
    a = 1;
    // 声明并初始化,允许多次赋值,但是不允许赋值类型不同,rust支持类型推断
    let mut b = 2;
    b = b * 2;
    const MAX_POINTS: u32 = 100_000;
    // 该下划线仅用以提升可读性
    // const 的值可在任何地方声明,并且在编译时就已经确定,声明时必须初始化
    // 使用 let 声明和使用 const 声明的区别是,const不接受运行时的赋值

    println!("a:{} b:{} MAX_POINTS:{}", a, b, MAX_POINTS);

    let a = 2;
    // 使用变量a来隐藏旧的变量a
    // 实际上这将创建一个新的变量,但是该变量占用a这个名称
    // 这允许你改变同名变量的类型
    let mut a = a * 2; // 2 * 2
    a *= a; // 4 * 4
    println!("a:{}", a); // a:16

    // rust 的四大标量类型 i和u的区别在于 i 带有符号,u 没有符号
    // 每一个有符号的变体可以储存包含从 -(2n - 1) 到 2n - 1 - 1 在内的数字，
    // 这里 n 是变体使用的位数。所以 i8 可以储存从 -(27) 到 27 - 1 在内的数字，
    // 也就是从 -128 到 127。无符号的变体可以储存从 0 到 2n - 1 的数字，
    // 所以 u8 可以储存从 0 到 28 - 1 的数字，也就是从 0 到 255。
    // 另外，isize 和 usize 类型依赖运行程序的计算机架构：64 位架构上它们是 64 位的，
    // 32 位架构上它们是 32 位的。
    // 整型 i8|u8 ,16,32,64,128,isize|usize
    let mut a: u8 = 255; // u8 类型最高值为255
                         // a += 1; // 整型溢出
                         // 当在 debug 模式编译时，Rust 检查这类问题并使程序 panic，
                         // release 构建中，Rust 不检测溢出，相反会进行一种被称为二进制补码包装（two’s complement wrapping）的操作。
                         // 简而言之，256 变成 0，257 变成 1
    println!("a:{}", a);

    // 浮点类型 f64 f32,f64精度更高为双精度浮点数
    let f: f64 = 2.0;

    let bl: bool = false;

    let z: char = 'z'; // 字符类型用单引号表示,大小为4个字节,字符不是字符串

    // 复合类型:元组,数组
    // 元组为复合类型
    let tup: (i32, f64, bool) = (1, 2.0, false);
    // 元素的取值,解构
    let (x, y, z) = tup;
    let x = tup.0; // 第零位

    // 数组的每个元素的值类型相同
    // 数组的长度为固定,不可扩充的
    let arr = [1, 2, 3, 4, 5];
    let arr2: [i32; 4] = [1, 2, 3, 4];
    let arr3 = [1; 3]; // 指定初始值的数组 = [1,1,1]
                       // 当数组访问出现下标溢出时会在运行时产生错误,编译时并不会出现错误
    let index = 4;
    // let v4 = arr3[index];

    // 这种表现形式被称为表达式
    // 函数调用是一个表达式。宏调用是一个表达式。{} 也是一个表达式
    let w = {
        // 代码块可以创建新的作用域
        let i2 = 3;
        // 没有使用分号结尾的最后一行被视为表达式的返回
        // 如果在表达式的结尾加上分号，它就变成了语句,而语句不会返回值
        index + i2
    };
}

// rust 函数与变量均使用 kebab-case 风格
// 最后一个语句被视为返回
// 也可使用 return 来提前返回
fn another_function(x: i32, y: i32) -> i32 {
    x + y
}


